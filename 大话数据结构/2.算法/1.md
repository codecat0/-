# 算法定义
**是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作**

# 算法的特性
1. 输入输出
   - 算法至少有0个或多个输入，至少有一个或多个输出
2. 有穷性
   - 算法在执行有限的步骤之后，自动结束而不会出现死循环，并且每一个步骤在可接受的时间内完成
3. 确定性
   - 算法的每一步都具有确定的含义，不会出现二义性
4. 可行性
   - 每一步都能够通过执行有限次数完成

# 算法设计的要求
1. 正确性
   - 算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案
2. 可读性
   - 便于阅读，理解和交流
3. 健壮性
   - 当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
4. 时间效率高和存储量低

# 算法效率的度量方法
1. 事后统计方法
   - 通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
2. 事前分析估算方法
   - 在计算机程序编制前，依据统计方法对算法进行估算

# 算法时间复杂度
1. 常数阶 O(1)
```c
int sum = 0,n = 100;  //执行一次
sum = (1+n)*n/2;        //执行一次
printf("%d",sum);     //执行一次
```
2. 线性阶 O(n)
```c
int i;
for(i = 0; i < n; i++)
{
    /*时间复杂度为 O(1) 的程序步骤序列*/
}
```
3. 对数阶
```c
int count = 1;
while(count < n)
{
    count = count * 2;
}
```
`分析`：由$2^x=n$，得出$x=log_2n$

4. 平方阶  O($n^2$)/O(m*n)
```c
int i,j;
for(i=0; i<m; i++)
{
    for(j=0; j<n; j++)
    {
         /*时间复杂度为 O(1) 的程序步骤序列*/
    }
}
```
5. 时间复杂度排序
   
   O(1)<O(logn)<O(n)<O(nlogn)<O($n^2$)<O($n^3$)<O($2^n$)<O(n!)<O($n^n$)