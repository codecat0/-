# 线性表的定义

1. 零个或多个数据元素的有限序列
2. 若记为($a_1,...,a_{i-1},a_i,a_{i+1},...a_n$)，则称$a_{i-1}$是$a_i$的直接前驱元素，$a_{i+1}$为$a_i$的直接后继元素，第一个元素无直接前驱，最后一个元素无直接后继，其他元素尤其仅有一个直接前驱和一个直接后继
3. 线性表元素的个数为线性表的长度，无元素称为空表

# 线性表的抽象数据类型

*说明：我比较喜欢使用引用，不过使用指针也是可以的*

```c
ADT 线性表(List)
Data
    一对一的关系，类型均为DataType
Operation
    InitList(&L)    //初始化操作，建立一个空的线性表L
    ListEmpty(L)    //判断线性表L是否为空
    ClearList(&L)   //清空线性表
    GetElem(L,i,&e) //将线性表L中的第i个位置的元素值返回给e
    LocateElem(L,e) //在线性表L中查找与e值相等的元素，若存在，返回该元素的位置，否则，返回0表示失败
    ListInsert(&L,i,e) //在线性表L中的第i个位置插入元素e
    ListDelete(&L,i,&e) //在线性表L中的第i个元素删除，并用e返回其值
    ListLength(L)    //返回线性表L的长度
endADT
```

对于实际问题中涉及关于线性表的更复杂的操作，完全可以用这些基本操作的组合来实现，例如：**实现线性表的并集操作**

```c
//将所有的在线性表Lb中但不在La中的数据元素插入到La
void union(List &La,List Lb)
{
    int La_len,Lb_len;
    ElemType e;
    La_len = ListLength(La);
    Lb_len = ListLength(Lb);
    for(i=1; i<=Lb_len; i++)
    {
        GetElem(Lb,i,e);
        if(!LocateList(La,e))
            ListInsert(La,++La_len,e);
    }
}
```

# 线性表的顺序存储结构

1. 顺序存储定义

   - 用一段连续的存储单元依次存储线性表的数据元素
2. 顺序存储方式

   ```c
   #define MAXSIZE 20
   typedef int ElemType;
   typedef struct
   {
       ElemType data[MAXSIZE];
       int length;
   }SqList;
   ```

   - 存储空间的起始位置：数组`data`，它的存储位置就是存储空间的存储位置
   - 线性表的最大存储容量：数组长度`MAXSIZE`
   - 线性表当前长度：`length`
3. 数据长度与线性表长度的区别
   - 数据的长度是存放线性表的存储空间的长度，存储分配后的这个量一般是不变的；
   - 线性表的长度是线性表中数据元素的个数，随着线性表的操作的进行，这个量是变化的
   - 在任意时刻，线性表的长度<=数据的长度
4. 地址计算方法
   - 存储器中的每个存储单元都有自己的编号，这个编号称为地址
   - 假设每个数据元素占用`c`个存储单元
      1. LOC($a_{i+1}$) = LOC($a_i$) + c
      2. LOC($a_i$) = LOC($a_1$) + (i-1)*c
